<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="/governing_dynamics/feed.xml" rel="self" type="application/atom+xml" /><link href="/governing_dynamics/" rel="alternate" type="text/html" /><updated>2024-04-16T10:05:59-04:00</updated><id>/governing_dynamics/feed.xml</id><title type="html">Governing Dynamics</title><subtitle>Govering Dynamics is my blog where i am going to share my experience in  Software Security, Engineering leadership , Java Language, Algorithms, Economics</subtitle><entry><title type="html">Parser Generators an Introduction</title><link href="/governing_dynamics/compilers/2024/04/15/parser-generator.html" rel="alternate" type="text/html" title="Parser Generators an Introduction" /><published>2024-04-15T06:21:52-04:00</published><updated>2024-04-15T06:21:52-04:00</updated><id>/governing_dynamics/compilers/2024/04/15/parser-generator</id><content type="html" xml:base="/governing_dynamics/compilers/2024/04/15/parser-generator.html"><![CDATA[<h3 id="prologue">Prologue</h3>
<p>The first stage of the compilation process is the pasring and undestanding the sytax of a language. Parsers job is look at code and make sure it follows the approved syntax of the grammer and also manipulate code structure to add or extract information</p>

<h3 id="what-are-parser-generators">What are Parser Generators</h3>
<p>Programs that recognize languages are called parsers or syntax analyzers. A grammar is just a set of rules, each one expressing the structure of a phrase. The ANTLR tool and tools like yaac translates grammars to parsers which are ready made code to parse the defined laguage in the grammar. Grammars themselves follow the syntax of a language optimized for specifying other languages</p>

<h3 id="an-example-of-a-grammar">An example of a grammar</h3>
<p>The grammar below can be used parse an array of integers.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">grammar</span> <span class="no">ArrayInit</span><span class="p">;</span>
<span class="n">init</span> <span class="p">:</span> <span class="s1">'{'</span> <span class="n">value</span> <span class="p">(</span><span class="s1">','</span> <span class="n">value</span><span class="p">)</span><span class="o">*</span> <span class="s1">'}'</span> <span class="p">;</span> <span class="c1"># define a array</span>
<span class="n">value</span> <span class="p">:</span> <span class="n">init</span> <span class="c1"># define the value as an INT Type</span>
      <span class="o">|</span> <span class="no">INT</span>
      <span class="p">;</span>
<span class="no">INT</span> <span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">+</span> <span class="p">;</span> <span class="c1"># define what is an INT</span>
<span class="no">WS</span> <span class="p">:</span> <span class="p">[</span> <span class="p">\</span><span class="n">t</span><span class="p">\</span><span class="n">n</span><span class="p">]</span><span class="o">+</span> <span class="o">-&gt;</span> <span class="n">skip</span> <span class="p">;</span> <span class="c1"># Skip white spaces</span></code></pre></figure>

<h3 id="how-to-organize-code">How to organize code</h3>

<p>We can organize the code in following way for Antlr to generate parsers from the g4 file. Keep the <code class="language-plaintext highlighter-rouge">g4</code> files in a <code class="language-plaintext highlighter-rouge">antlr4</code> directory and make the sure the package structure matches between the <code class="language-plaintext highlighter-rouge">java</code> code and <code class="language-plaintext highlighter-rouge">antlr4</code></p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">└── exampleAntlr
    ├── LICENSE
    ├── README.md
    ├── exampleAntlr.iml
    ├── pom.xml
    ├── src
    │   └── main
    │       ├── antlr4
    │       │   └── com
    │       │       └── srini
    │       │           └── antrl4
    │       │               ├── ArrayInit.g4
    │       ├── java
    │       │   └── com
    │       │       └── srini
    │       │           └── antrl4
    │       │               └── TestAntlr.java</code></pre></figure>

<h3 id="run-the-generated-parser">Run the generated parser</h3>
<p>A maven install can generate the lexer parser for the g4 grammar. 
The below code can take an array like <code class="language-plaintext highlighter-rouge">{1,2,3,4}</code> and parse it and form the tree of the its components.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nc">ANTLRInputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ANTLRInputStream</span><span class="o">(</span><span class="s">"{1,2,3,4}"</span><span class="o">);</span>
<span class="nc">ArrayInitLexer</span> <span class="n">lexer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayInitLexer</span><span class="o">(</span><span class="n">input</span><span class="o">);</span> 
<span class="nc">CommonTokenStream</span> <span class="n">tokens</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CommonTokenStream</span><span class="o">(</span><span class="n">lexer</span><span class="o">);</span>
<span class="nc">ArrayInitParser</span> <span class="n">parser</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayInitParser</span><span class="o">(</span><span class="n">tokens</span><span class="o">);</span>
<span class="nc">ParseTree</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="na">init</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">tree</span><span class="o">.</span><span class="na">toStringTree</span><span class="o">(</span><span class="n">parser</span><span class="o">));</span></code></pre></figure>

<h3 id="the-output-of-the-parser">The output of the parser</h3>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">(</span>init <span class="o">{</span> <span class="o">(</span>value 1<span class="o">)</span> , <span class="o">(</span>value 2<span class="o">)</span> , <span class="o">(</span>value 3<span class="o">)</span> , <span class="o">(</span>value 4<span class="o">)</span> <span class="o">})</span></code></pre></figure>

<p>So the parser has taken the array and broken it down to its compoenents of array start token the integer values and array end token.Now when we look at grammar syntax we can relate to it better.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">init {</code> refers to start of an array represented in the grammer line no 1<code class="language-plaintext highlighter-rouge">init : '{' </code></li>
  <li><code class="language-plaintext highlighter-rouge">value</code> is the Interger values of the array</li>
</ul>

<h3 id="a-bad-input">A bad input</h3>

<p>If we have input like <code class="language-plaintext highlighter-rouge">{1,2,3sadas,4}</code>  which has a bad integer in the array then the parser would generate an error</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">line 1:6 token recognition error at: <span class="s1">'s'</span>
line 1:7 token recognition error at: <span class="s1">'a'</span>
line 1:8 token recognition error at: <span class="s1">'d'</span>
line 1:9 token recognition error at: <span class="s1">'a'</span>
line 1:10 token recognition error at: <span class="s1">'s'</span></code></pre></figure>]]></content><author><name></name></author><category term="Compilers" /><summary type="html"><![CDATA[Prologue The first stage of the compilation process is the pasring and undestanding the sytax of a language. Parsers job is look at code and make sure it follows the approved syntax of the grammer and also manipulate code structure to add or extract information]]></summary></entry><entry><title type="html">Skin in the game</title><link href="/governing_dynamics/engineering/leadership/2024/04/15/skin-in-the-game.html" rel="alternate" type="text/html" title="Skin in the game" /><published>2024-04-15T06:21:52-04:00</published><updated>2024-04-15T06:21:52-04:00</updated><id>/governing_dynamics/engineering/leadership/2024/04/15/skin-in-the-game</id><content type="html" xml:base="/governing_dynamics/engineering/leadership/2024/04/15/skin-in-the-game.html"><![CDATA[<h3 id="prologue">Prologue</h3>]]></content><author><name></name></author><category term="Engineering" /><category term="Leadership" /><summary type="html"><![CDATA[Prologue]]></summary></entry></feed>