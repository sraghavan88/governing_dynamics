<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="/governing_dynamics/feed.xml" rel="self" type="application/atom+xml" /><link href="/governing_dynamics/" rel="alternate" type="text/html" /><updated>2024-04-16T03:19:16-04:00</updated><id>/governing_dynamics/feed.xml</id><title type="html">Governing Dynamics</title><subtitle>Govering Dynamics is my blog where i am going to share my experience in  Software Security, Engineering leadership , Java Language, Algorithms, Economics</subtitle><entry><title type="html">Parser Generators</title><link href="/governing_dynamics/compilers/2024/04/15/parser-generator.html" rel="alternate" type="text/html" title="Parser Generators" /><published>2024-04-15T06:21:52-04:00</published><updated>2024-04-15T06:21:52-04:00</updated><id>/governing_dynamics/compilers/2024/04/15/parser-generator</id><content type="html" xml:base="/governing_dynamics/compilers/2024/04/15/parser-generator.html"><![CDATA[<h3 id="prologue">Prologue</h3>
<p>The first stage of the compilation process is the pasring and undestanding  the sytax of the languages. Parsers job is look at code and make sure it follows the approved syntax of the grammer and also manipulate code structure to add or extract information</p>

<h3 id="what-are-parser-generators">What are Parser Generators</h3>
<p>Programs that recognize languages are called parsers or syntax analyzers. A grammar is just a set of rules, each one expressing the structure of a phrase. The ANTLR tool and tools like yaac translates grammars to parsers which are ready made code to parse the defined laguage in the grammar. Grammars themselves follow the syntax of a language optimized for specifying other languages</p>

<h3 id="an-example-of-a-grammar">An example of a grammar</h3>
<p>The grammar below can be used parse an array of integers.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">grammar</span> <span class="no">ArrayInit</span><span class="p">;</span>
<span class="n">init</span> <span class="p">:</span> <span class="s1">'{'</span> <span class="n">value</span> <span class="p">(</span><span class="s1">','</span> <span class="n">value</span><span class="p">)</span><span class="o">*</span> <span class="s1">'}'</span> <span class="p">;</span>
<span class="n">value</span> <span class="p">:</span> <span class="n">init</span>
      <span class="o">|</span> <span class="no">INT</span>
      <span class="p">;</span>
<span class="no">INT</span> <span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">+</span> <span class="p">;</span>
<span class="no">WS</span> <span class="p">:</span> <span class="p">[</span> <span class="p">\</span><span class="n">t</span><span class="p">\</span><span class="n">n</span><span class="p">]</span><span class="o">+</span> <span class="o">-&gt;</span> <span class="n">skip</span> <span class="p">;</span></code></pre></figure>

<h3 id="how-to-organize-code">How to organize code</h3>

<p>We can orgaize the code in following way for Antlr to generate parsers from the g4 file.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">└── exampleAntlr
    ├── LICENSE
    ├── README.md
    ├── exampleAntlr.iml
    ├── pom.xml
    ├── src
    │   └── main
    │       ├── antlr4
    │       │   └── com
    │       │       └── srini
    │       │           └── antrl4
    │       │               ├── ArrayInit.g4
    │       ├── java
    │       │   └── com
    │       │       └── srini
    │       │           └── antrl4
    │       │               └── TestAntlr.java</code></pre></figure>

<h3 id="run-the-generated-parser">Run the generated parser</h3>
<p>A maven install can generate the lexer parser for the g4 grammar. 
The below code can take an array and parse it and form the tree</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nc">ANTLRInputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ANTLRInputStream</span><span class="o">(</span><span class="s">"{1,2,3,4}"</span><span class="o">);</span>
<span class="nc">ArrayInitLexer</span> <span class="n">lexer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayInitLexer</span><span class="o">(</span><span class="n">input</span><span class="o">);</span> 
<span class="nc">CommonTokenStream</span> <span class="n">tokens</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CommonTokenStream</span><span class="o">(</span><span class="n">lexer</span><span class="o">);</span>
<span class="nc">ArrayInitParser</span> <span class="n">parser</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayInitParser</span><span class="o">(</span><span class="n">tokens</span><span class="o">);</span>
<span class="nc">ParseTree</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="na">init</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">tree</span><span class="o">.</span><span class="na">toStringTree</span><span class="o">(</span><span class="n">parser</span><span class="o">));</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">(</span>init <span class="o">{</span> <span class="o">(</span>value 1<span class="o">)</span> , <span class="o">(</span>value 2<span class="o">)</span> , <span class="o">(</span>value 3<span class="o">)</span> , <span class="o">(</span>value 4<span class="o">)</span> <span class="o">})</span></code></pre></figure>]]></content><author><name></name></author><category term="Compilers" /><summary type="html"><![CDATA[Prologue The first stage of the compilation process is the pasring and undestanding the sytax of the languages. Parsers job is look at code and make sure it follows the approved syntax of the grammer and also manipulate code structure to add or extract information]]></summary></entry><entry><title type="html">Skin in the game</title><link href="/governing_dynamics/engineering/leadership/2024/04/15/skin-in-the-game.html" rel="alternate" type="text/html" title="Skin in the game" /><published>2024-04-15T06:21:52-04:00</published><updated>2024-04-15T06:21:52-04:00</updated><id>/governing_dynamics/engineering/leadership/2024/04/15/skin-in-the-game</id><content type="html" xml:base="/governing_dynamics/engineering/leadership/2024/04/15/skin-in-the-game.html"><![CDATA[<h3 id="prologue">Prologue</h3>]]></content><author><name></name></author><category term="Engineering" /><category term="Leadership" /><summary type="html"><![CDATA[Prologue]]></summary></entry></feed>